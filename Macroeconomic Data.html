<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Country Macroeconomic Data</title>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Global Minimalist macOSâ€“Style Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255,255,255,0.2);
        }

        html {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.1) transparent;
        }

        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Source Code Pro', monospace;
            background-color: #000;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            height: 100vh; 
            box-sizing: border-box; 
            overflow: hidden; /* Prevent body scroll, panes will scroll */
        }

        *, *:before, *:after {
            box-sizing: inherit; 
        }

        .page-header {
            background-color: #111111;
            color: #f0f0f0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a2a;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .header-title {
            font-size: 20px;
            font-weight: bold;
            margin: 0;
            color: #f0f0f0;
        }

        .country-select {
            padding: 8px 12px;
            border: 1px solid #2a2a2a;
            border-radius: 5px;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Source Code Pro', monospace;
            font-size: 14px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23f0f0f0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-13z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 10px 10px;
            padding-right: 30px;
        }

        .country-select:hover {
            border-color: #555;
        }

        .country-select option {
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        .content-container {
            display: flex;
            flex-direction: row; 
            flex: 1; 
            overflow: hidden; 
        }

        .left-pane {
            width: 57%; 
            min-width: 200px; 
            padding: 20px;
            overflow-y: auto;
            position: relative; 
        }

        .resizer-x {
            width: 8px; 
            background-color: #2a2a2a; 
            cursor: col-resize;
            flex-shrink: 0; 
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none; 
        }
        .resizer-x::before {
            content: '';
            width: 2px;
            height: 25px;
            background-color: #555;
            border-radius: 1px;
        }


        .right-pane {
            width: calc(43% - 8px); 
            min-width: 200px; 
            padding: 20px;
            display: flex;
            flex-direction: column; 
            height: 100%; 
            position: relative; /* Needed for absolute positioning of pane-loading-overlay */
        }
       
        #historical-data-title {
            font-size: 18px; 
            font-weight: bold;
            color: #f0f0f0;
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            flex-shrink: 0; 
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background-color: #1a1a1a;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #222;
        }

        .data-table thead th {
            background-color: #222;
            color: #fff;
            padding: 10px 12px; 
            text-align: left;
            font-size: 13px; 
            font-weight: 600;
            border-bottom: 1px solid #333;
            position: sticky; 
            top: 0;
            z-index: 2; 
        }

        .data-table tbody td {
            padding: 10px 12px; 
            text-align: left;
            border-bottom: 1px solid #333;
            font-size: 13px; 
            white-space: nowrap; 
        }
       
        .data-table tbody tr {
            cursor: pointer; 
            transition: background-color 0.2s ease;
        }
        .data-table tbody tr:hover td {
            background-color: #2a2a2a;
        }
        .data-table tbody tr.active-indicator td {
            background-color: #333; 
            color: #fff;
        }
        .data-table tbody tr.active-indicator .data-value,
        .data-table tbody tr.active-indicator .data-unit-main { 
            color: #fff;
        }


        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .data-table tbody tr:nth-child(odd):not(.active-indicator) td { 
            background-color: #202020;
        }


        .data-value {
            font-weight: 700;
            color: #fff;
        }

        .data-unit-main { 
            color: #aaa;
            font-size: 12px;
            margin-left: 5px;
        }
       
        .custom-legend-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center; 
            flex-wrap: wrap; 
            justify-content: flex-start; 
            flex-shrink: 0; 
        }

        .legend-toggle-button, .control-button, .stepper-button {
            background-color: #1a1a1a;
            color: #f0f0f0; 
            border: 1px solid #333;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Source Code Pro', monospace;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            white-space: nowrap; 
        }

        .legend-toggle-button:hover, .control-button:hover, .stepper-button:hover {
            background-color: #2a2a2a;
            border-color: #555;
        }

        .legend-toggle-button.active {
            background-color: #2c2c2c; 
            border-color: #f0f0f0; 
        }
       
        .data-points-control {
            display: flex;
            align-items: center;
            gap: 8px; 
            margin-left: auto; 
        }

        .input-group-combined {
            display: flex;
            align-items: center;
        }

        .stepper-button {
            padding: 6px 8px; 
        }
       
        #decreaseDataPoints {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right-width: 0px; 
        }

        #dataPointsInput {
            padding: 6px 10px;
            border: 1px solid #333;
            border-radius: 0; 
            background-color: #101010;
            color: #f0f0f0;
            font-family: 'Source Code Pro', monospace;
            font-size: 13px;
            width: 70px; 
            text-align: center;
            -moz-appearance: textfield; 
        }
        #dataPointsInput::-webkit-inner-spin-button,
        #dataPointsInput::-webkit-outer-spin-button {
            -webkit-appearance: none; 
            margin: 0;
        }
        #dataPointsInput:focus {
            border-color: #555; 
            outline: none;
            position: relative; 
            z-index: 1;
        }
       
        #increaseDataPoints {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left-width: 0px; 
        }
       

        .chart-outer-container { 
            width: 100%;
            height: 300px; 
            margin-bottom: 20px; 
            background-color: #1a1a1a;
            padding:10px;
            border-radius: 5px;
            position: relative; 
            flex-shrink: 0; 
        }
        .chart-scroll-wrapper { 
            width: 100%;
            height: 100%;
            overflow-x: hidden; 
            overflow-y: hidden;
        }

        #historical-chart { 
             /* Height and width will be set by JS */
        }

        .historical-table-wrapper {
            flex-grow: 1; 
            overflow-y: auto; 
            position: relative; 
            border: 1px solid #222; 
            border-radius: 5px; 
            background-color: #1a1a1a; 
            display: flex; 
            flex-direction: column; 
        }

        .historical-data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .historical-data-table thead th {
            background-color: #222; 
            color: #fff;
            padding: 10px; 
            text-align: left;
            font-size: 13px; 
            font-weight: 600;
            border-bottom: 1px solid #333;
            position: sticky; 
            top: 0; 
            z-index: 1; 
        }

        .historical-data-table tbody td {
            padding: 10px; 
            text-align: left;
            border-bottom: 1px solid #333;
            font-size: 13px; 
        }

        .historical-data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .historical-data-table tbody tr:nth-child(odd) td {
            background-color: #202020;
        }

        .historical-data-table tbody tr:hover td {
            background-color: #2a2a2a;
        }
        
        /* Full screen loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index for full screen */
            display: none; 
        }

        /* Pane-specific loading overlay */
        .pane-loading-overlay {
            position: absolute; /* Relative to its parent (.right-pane) */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.65); /* Slightly less dark or different color */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10; /* Lower than full-screen, but above pane content */
            border-radius: 5px; /* Optional: match parent's border-radius */
            display: none; /* Initially hidden */
        }


        .loading-spinner {
            border: 5px solid #ccc;
            border-top: 5px solid #4CAF50; 
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite; 
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="page-header">
        <h1 class="header-title">Macroeconomic Data</h1>
        <select id="countrySelect" class="country-select">
            <option value="USD">United States</option>
            <option value="EUR">Euro Area</option>
            <option value="GBP">United Kingdom</option>
            <option value="JPY">Japan</option>
            <option value="AUD">Australia</option>
            <option value="CAD">Canada</option>
            <option value="CHF">Switzerland</option>
            <option value="NZD">New Zealand</option>
            <option value="CNY">China</option>
        </select>
    </div>

    <div class="content-container">
        <div class="left-pane">
            <table class="data-table" id="mainDataTable">
                <thead>
                    <tr>
                        <th>Indicator</th>
                        <th>Latest</th>
                        <th>Previous</th>
                        <th>Forecast</th>
                        <th>Surprise Index</th>
                        <th>Unit</th>
                        <th>Date</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
        <div class="right-pane">
            <div class="pane-loading-overlay" id="rightPaneLoadingOverlay">
                <div class="loading-spinner"></div>
            </div>
            <h2 id="historical-data-title">Historical Data</h2>
            <div class="custom-legend-controls">
                <button class="legend-toggle-button" data-dataset-index="0">Actual</button>
                <button class="legend-toggle-button" data-dataset-index="1">Forecast</button>
                <button class="legend-toggle-button" data-dataset-index="2">Surprise Index</button>
               
                <div class="data-points-control">
                    <div class="input-group-combined">
                        <button id="decreaseDataPoints" class="stepper-button" title="Decrease data points">-</button>
                        <input type="number" id="dataPointsInput" placeholder="# Data" min="1" title="Enter number of data points">
                        <button id="increaseDataPoints" class="stepper-button" title="Increase data points">+</button>
                        </div>
                    <button id="showAllDataButton" class="control-button" title="Show all historical data points">Reset</button>
                </div>
            </div>
            <div class="chart-outer-container">
                <div class="chart-scroll-wrapper">
                    <canvas id="historical-chart"></canvas>
                </div>
            </div>
            <div class="historical-table-wrapper"> 
                <table class="historical-data-table">
                    <thead>
                        <tr>
                            <th>Year</th>
                            <th>Actual</th>
                            <th>Forecast</th>
                            <th>Surprise Index</th>
                        </tr>
                    </thead>
                    <tbody id="historical-data-table-body">
                        </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // --- Google Sheet Configuration ---
        const GOOGLE_SHEET_IDS = { 
            USD: '1NSRaFuf5fNwbaZvgXgVKTr97v6aSp8-EXwSgM0ZXKcc',
            EUR: '11SSoWwYCpe1oGJmgkxdsFyFWsHBV_xqhZKOOf6iQj4A',
            GBP: '1kL2HimpF3llcFS5Pp0ZXY5dPK6GVwTWySuQ3lRdPzjk' // Added GBP Sheet ID
        };
        const GOOGLE_API_KEY = 'AIzaSyARkBKvargdD7TRQ_gje61jdRyOiuR08e4'; 

        // --- DOM Elements ---
        const fullScreenLoadingOverlay = document.querySelector('.loading-overlay'); 
        const rightPaneLoadingOverlay = document.getElementById('rightPaneLoadingOverlay');
        const historicalChartCanvasEl = document.getElementById('historical-chart'); 
        const historicalChartScrollWrapper = historicalChartCanvasEl.parentNode; 
        const historicalDataTableBody = document.getElementById('historical-data-table-body');
        const countrySelect = document.getElementById('countrySelect');
        const mainDataTableBody = document.getElementById('mainDataTable').querySelector('tbody');
        const historicalDataTitleEl = document.getElementById('historical-data-title');
       
        const leftPane = document.querySelector('.left-pane');
        const rightPane = document.querySelector('.right-pane');
        const contentContainer = document.querySelector('.content-container');

        const dataPointsInput = document.getElementById('dataPointsInput');
        const showAllDataButton = document.getElementById('showAllDataButton');
        const decreaseDataPointsButton = document.getElementById('decreaseDataPoints');
        const increaseDataPointsButton = document.getElementById('increaseDataPoints');

        // --- State Variables ---
        let selectedCountry = 'USD'; 
        let historicalChartInstance = null; 
        let activeIndicatorId = ''; 
        let currentDataPointsToShow = 15; 
        let forecastMarkerImage = null; 

        // --- Helper Function for Column Letters ---
        function colToExcel(col) { 
            let s = '', t;
            while (col >= 0) {
                t = col % 26;
                s = String.fromCharCode(t + 65) + s;
                col = Math.floor(col / 26) - 1;
            }
            return s;
        }

        // --- Data Structures ---
        const countrySpecificConfig = {
            USD: {
                sheetIdKey: 'USD',
                latestSheetName: 'United States',
                latestSheetRange: 'B2:G33', 
                latestDataColumns: { latest: 0, previous: 1, forecast: 2, surprise: 3, date: 5 }, 
                indicatorSetup: [
                    { id: 'gdp-sales-qq', name: 'GDP Sales q/q', dataKey: 'gdpSalesQq', unit: 'q/q', historicalSheet: 'US Source', historicalRanges: { date: 'A3:A', actual: 'B3:B', forecast: 'C3:C', surprise: 'E3:E' } },
                    { id: 'gdp-qq', name: 'GDP q/q', dataKey: 'gdpQq', unit: 'q/q', historicalSheet: 'US Source', historicalRanges: { date: 'G3:G', actual: 'H3:H', forecast: 'I3:I', surprise: 'K3:K' } },
                    { id: 'adp-nonfarm-employment-change', name: 'ADP Nonfarm Employment Change', dataKey: 'adpNonfarmEmploymentChange', unit: 'K', historicalSheet: 'US Source', historicalRanges: { date: 'M3:M', actual: 'N3:N', forecast: 'O3:O', surprise: 'Q3:Q' } },
                    { id: 'avg-hourly-earnings-mm', name: 'Average Hourly Earnings m/m', dataKey: 'avgHourlyEarningsMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'S3:S', actual: 'T3:T', forecast: 'U3:U', surprise: 'W3:W' } },
                    { id: 'avg-hourly-earnings-yy', name: 'Average Hourly Earnings y/y', dataKey: 'avgHourlyEarningsYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'Y3:Y', actual: 'Z3:Z', forecast: 'AA3:AA', surprise: 'AC3:AC' } },
                    { id: 'initial-jobless-claims', name: 'Initial Jobless Claims', dataKey: 'initialJoblessClaims', unit: 'K', historicalSheet: 'US Source', historicalRanges: { date: 'AE3:AE', actual: 'AF3:AF', forecast: 'AG3:AG', surprise: 'AI3:AI' } },
                    { id: 'jolts-job-openings', name: 'JOLTS Job Openings', dataKey: 'joltsJobOpenings', unit: 'M', historicalSheet: 'US Source', historicalRanges: { date: 'AK3:AK', actual: 'AL3:AL', forecast: 'AM3:AM', surprise: 'AO3:AO' } },
                    { id: 'nonfarm-payrolls', name: 'Nonfarm Payrolls', dataKey: 'nonfarmPayrolls', unit: 'K', historicalSheet: 'US Source', historicalRanges: { date: 'AQ3:AQ', actual: 'AR3:AR', forecast: 'AS3:AS', surprise: 'AU3:AU' } }, 
                    { id: 'unemployment-rate', name: 'Unemployment Rate', dataKey: 'unemploymentRate', unit: '%', historicalSheet: 'US Source', historicalRanges: { date: 'AW3:AW', actual: 'AX3:AX', forecast: 'AY3:AY', surprise: 'BA3:BA' } },
                    { id: 'cpi-yy', name: 'CPI y/y', dataKey: 'cpiYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'BC3:BC', actual: 'BD3:BD', forecast: 'BE3:BE', surprise: 'BG3:BG' } },
                    { id: 'core-cpi-yy', name: 'Core CPI y/y', dataKey: 'coreCpiYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'BI3:BI', actual: 'BJ3:BJ', forecast: 'BK3:BK', surprise: 'BM3:BM' } },
                    { id: 'cpi-mm', name: 'CPI m/m', dataKey: 'cpiMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'BO3:BO', actual: 'BP3:BP', forecast: 'BQ3:BQ', surprise: 'BS3:BS' } },
                    { id: 'core-cpi-mm', name: 'Core CPI m/m', dataKey: 'coreCpiMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'BU3:BU', actual: 'BV3:BV', forecast: 'BW3:BW', surprise: 'BY3:BY' } },
                    { id: 'core-pce-price-index-yy', name: 'Core PCE Price Index y/y', dataKey: 'corePcePriceIndexYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'CA3:CA', actual: 'CB3:CB', forecast: 'CC3:CC', surprise: 'CE3:CE' } },
                    { id: 'core-ppi-mm', name: 'Core PPI m/m', dataKey: 'corePpiMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'CG3:CG', actual: 'CH3:CH', forecast: 'CI3:CI', surprise: 'CK3:CK' } },
                    { id: 'core-ppi-yy', name: 'Core PPI y/y', dataKey: 'corePpiYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'CM3:CM', actual: 'CN3:CN', forecast: 'CO3:CO', surprise: 'CQ3:CQ' } },
                    { id: 'michigan-5y-inflation-expectations', name: 'Michigan 5-Year Inflation Expectations', dataKey: 'michigan5yInflationExpectations', unit: '%', historicalSheet: 'US Source', historicalRanges: { date: 'CS3:CS', actual: 'CT3:CT', forecast: 'CU3:CU', surprise: 'CW3:CW' } },
                    { id: 'michigan-inflation-expectations', name: 'Michigan Inflation Expectations', dataKey: 'michiganInflationExpectations', unit: '%', historicalSheet: 'US Source', historicalRanges: { date: 'CY3:CY', actual: 'CZ3:CZ', forecast: 'DA3:DA', surprise: 'DC3:DC' } },
                    { id: 'pce-price-index-yy', name: 'PCE Price Index y/y', dataKey: 'pcePriceIndexYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'DE3:DE', actual: 'DF3:DF', forecast: 'DG3:DG', surprise: 'DI3:DI' } },
                    { id: 'ppi-mm', name: 'PPI m/m', dataKey: 'ppiMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'DK3:DK', actual: 'DL3:DL', forecast: 'DM3:DM', surprise: 'DO3:DO' } },
                    { id: 'ppi-yy', name: 'PPI y/y', dataKey: 'ppiYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'DQ3:DQ', actual: 'DR3:DR', forecast: 'DS3:DS', surprise: 'DU3:DU' } },
                    { id: 'fed-interest-rate-decision', name: 'Fed Interest Rate Decision', dataKey: 'fedInterestRateDecision', unit: '%', historicalSheet: 'US Source', historicalRanges: { date: 'DW3:DW', actual: 'DX3:DX', forecast: '', surprise: '' } }, 
                    { id: 'current-account', name: 'Current Account', dataKey: 'currentAccount', unit: 'Billion', historicalSheet: 'US Source', historicalRanges: { date: 'EC3:EC', actual: 'ED3:ED', forecast: 'EE3:EE', surprise: 'EG3:EG' } },
                    { id: 'ism-manufacturing-pmi', name: 'ISM Manufacturing PMI', dataKey: 'ismManufacturingPmi', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'EI3:EI', actual: 'EJ3:EJ', forecast: 'EK3:EK', surprise: 'EM3:EM' } },
                    { id: 'ism-non-manufacturing-pmi', name: 'ISM Non-Manufacturing PMI', dataKey: 'ismNonManufacturingPmi', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'EO3:EO', actual: 'EP3:EP', forecast: 'EQ3:EQ', surprise: 'ES3:ES' } },
                    { id: 'sp-global-composite-pmi', name: 'S&P Global Composite PMI', dataKey: 'spGlobalCompositePmi', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'EU3:EU', actual: 'EV3:EV', forecast: 'EW3:EW', surprise: 'EY3:EY' } },
                    { id: 'sp-global-manufacturing-pmi', name: 'S&P Global Manufacturing PMI', dataKey: 'spGlobalManufacturingPmi', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'FG3:FG', actual: 'FH3:FH', forecast: 'FI3:FI', surprise: 'FK3:FK' } },
                    { id: 'sp-global-services-pmi', name: 'S&P Global Services PMI', dataKey: 'spGlobalServicesPmi', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'FA3:FA', actual: 'FB3:FB', forecast: 'FC3:FC', surprise: 'FE3:FE' } },
                    { id: 'cb-consumer-confidence-index', name: 'CB Consumer Confidence Index', dataKey: 'cbConsumerConfidenceIndex', unit: 'Index', historicalSheet: 'US Source', historicalRanges: { date: 'FM3:FM', actual: 'FN3:FN', forecast: 'FO3:FO', surprise: 'FQ3:FQ' } },
                    { id: 'core-retail-sales-mm', name: 'Core Retail Sales m/m', dataKey: 'coreRetailSalesMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'FS3:FS', actual: 'FT3:FT', forecast: 'FU3:FU', surprise: 'FV3:FV' } },
                    { id: 'retail-sales-mm', name: 'Retail Sales m/m', dataKey: 'retailSalesMm', unit: '% m/m', historicalSheet: 'US Source', historicalRanges: { date: 'FY3:FY', actual: 'FZ3:FZ', forecast: 'GA3:GA', surprise: 'GC3:GC' } },
                    { id: 'retail-sales-yy', name: 'Retail Sales y/y', dataKey: 'retailSalesYy', unit: '% y/y', historicalSheet: 'US Source', historicalRanges: { date: 'GE3:GE', actual: 'GF3:GF', forecast: 'GG3:GG', surprise: 'GI3:GI' } }
                ]
            },
            EUR: {
                sheetIdKey: 'EUR',
                latestSheetName: 'Overview',
                latestSheetRange: 'B2:G28', 
                latestDataColumns: { latest: 0, previous: 1, forecast: 2, surprise: 3, date: 5 }, 
                indicatorSetup: [] 
            },
            GBP: { // Added GBP configuration
                sheetIdKey: 'GBP',
                latestSheetName: 'Overview',
                latestSheetRange: 'B2:G30', // 29 indicators
                latestDataColumns: { latest: 0, previous: 1, forecast: 2, surprise: 3, date: 5 }, // Date from Col G (index 5), Col F (Unit from sheet) is skipped
                indicatorSetup: [] // Will be populated by generateGbpHistoricalConfig
            }
        };
        
        function generateEurHistoricalConfig() {
            const eurIndicatorsBase = [
                { id: 'gdp-qq-eur', name: 'GDP q/q', dataKey: 'gdpQqEur', unit: 'q/q' },
                { id: 'gdp-yy-eur', name: 'GDP y/y', dataKey: 'gdpYyEur', unit: '% y/y' },
                { id: 'unemployment-rate-eur', name: 'Unemployment Rate', dataKey: 'unemploymentRateEur', unit: '%' },
                { id: 'wage-costs-yy-eur', name: 'Wage Costs y/y', dataKey: 'wageCostsYyEur', unit: '% y/y' },
                { id: 'labour-cost-index-eur', name: 'Labour Cost Index', dataKey: 'labourCostIndexEur', unit: 'Index' },
                { id: 'employment-level-eur', name: 'Employment Level', dataKey: 'employmentLevelEur', unit: 'K' },
                { id: 'cpi-eur', name: 'CPI', dataKey: 'cpiEur', unit: '% y/y' },
                { id: 'cpi-mm-eur', name: 'CPI m/m', dataKey: 'cpiMmEur', unit: '% m/m' },
                { id: 'cpi-yy-eur', name: 'CPI y/y', dataKey: 'cpiYyEur', unit: '% y/y' },
                { id: 'core-cpi-eur', name: 'Core CPI', dataKey: 'coreCpiEur', unit: '% y/y' },
                { id: 'core-cpi-mm-eur', name: 'Core CPI m/m', dataKey: 'coreCpiMmEur', unit: '% m/m' },
                { id: 'core-cpi-yy-eur', name: 'Core CPI y/y', dataKey: 'coreCpiYyEur', unit: '% y/y' },
                { id: 'ppi-mm-eur', name: 'PPI m/m', dataKey: 'ppiMmEur', unit: '% m/m' },
                { id: 'ppi-yy-eur', name: 'PPI y/y', dataKey: 'ppiYyEur', unit: '% y/y' },
                { id: 'ecb-interest-rate-decision-eur', name: 'ECB Interest Rate Decision', dataKey: 'ecbInterestRateDecisionEur', unit: '%' },
                { id: 'current-account-eur', name: 'Current Account', dataKey: 'currentAccountEur', unit: 'Billion' }, // Assuming Billion EUR, adjust if needed
                { id: 'trade-balance-eur', name: 'Trade Balance', dataKey: 'tradeBalanceEur', unit: 'Billion' }, // Assuming Billion EUR
                { id: 'business-climate-indicator-eur', name: 'Business Climate Indicator', dataKey: 'businessClimateIndicatorEur', unit: 'Index' },
                { id: 'economic-sentiment-indicator-eur', name: 'Economic Sentiment Indicator', dataKey: 'economicSentimentIndicatorEur', unit: 'Index' },
                { id: 'sp-global-composite-pmi-eur', name: 'S&P Global Composite PMI', dataKey: 'spGlobalCompositePmiEur', unit: 'Index' },
                { id: 'sp-global-construction-pmi-eur', name: 'S&P Global Construction PMI', dataKey: 'spGlobalConstructionPmiEur', unit: 'Index' },
                { id: 'sp-global-manufacturing-pmi-eur', name: 'S&P Global Manufacturing PMI', dataKey: 'spGlobalManufacturingPmiEur', unit: 'Index' },
                { id: 'sp-global-services-pmi-eur', name: 'S&P Global Services PMI', dataKey: 'spGlobalServicesPmiEur', unit: 'Index' },
                { id: 'zew-economic-sentiment-indicator-eur', name: 'ZEW Economic Sentiment Indicator', dataKey: 'zewEconomicSentimentIndicatorEur', unit: 'Index' },
                { id: 'consumer-confidence-index-eur', name: 'Consumer Confidence Index', dataKey: 'consumerConfidenceIndexEur', unit: 'Index' },
                { id: 'retail-sales-mm-eur', name: 'Retail Sales m/m', dataKey: 'retailSalesMmEur', unit: '% m/m' },
                { id: 'retail-sales-yy-eur', name: 'Retail Sales y/y', dataKey: 'retailSalesYyEur', unit: '% y/y' },
            ];

            countrySpecificConfig.EUR.indicatorSetup = eurIndicatorsBase.map((indicator, index) => {
                const baseColIndex = index * 6; 
                const dateCol = colToExcel(baseColIndex + 0);
                const actualCol = colToExcel(baseColIndex + 1);
                const forecastCol = colToExcel(baseColIndex + 2);
                const surpriseCol = colToExcel(baseColIndex + 4);
                const startRow = 4; 

                return {
                    ...indicator,
                    historicalSheet: 'Historical Data',
                    historicalRanges: {
                        date: `${dateCol}${startRow}:${dateCol}`,
                        actual: `${actualCol}${startRow}:${actualCol}`,
                        forecast: `${forecastCol}${startRow}:${forecastCol}`,
                        surprise: `${surpriseCol}${startRow}:${surpriseCol}`
                    }
                };
            });
        }
        generateEurHistoricalConfig(); 

        function generateGbpHistoricalConfig() {
            const gbpIndicatorsBase = [
                { id: 'gdp-qq-gbp', name: 'GDP q/q', dataKey: 'gdpQqGbp', unit: '% q/q' },
                { id: 'gdp-yy-gbp', name: 'GDP y/y', dataKey: 'gdpYyGbp', unit: '% y/y' },
                { id: 'claimant-count-change-gbp', name: 'Claimant Count Change', dataKey: 'claimantCountChangeGbp', unit: 'K' },
                { id: 'employment-change-3m-gbp', name: 'Employment Change 3-months', dataKey: 'employmentChange3mGbp', unit: 'K' },
                { id: 'unemployment-rate-gbp', name: 'Unemployment Rate', dataKey: 'unemploymentRateGbp', unit: '%' },
                { id: 'cpi-gbp', name: 'CPI', dataKey: 'cpiGbp', unit: '% y/y' }, // Assuming main CPI is y/y
                { id: 'cpi-mm-gbp', name: 'CPI m/m', dataKey: 'cpiMmGbp', unit: '% m/m' },
                { id: 'cpi-yy-gbp', name: 'CPI y/y', dataKey: 'cpiYyGbp', unit: '% y/y' },
                { id: 'core-cpi-mm-gbp', name: 'Core CPI m/m', dataKey: 'coreCpiMmGbp', unit: '% m/m' },
                { id: 'core-cpi-yy-gbp', name: 'Core CPI y/y', dataKey: 'coreCpiYyGbp', unit: '% y/y' },
                { id: 'ppi-input-mm-gbp', name: 'PPI Input m/m', dataKey: 'ppiInputMmGbp', unit: '% m/m' },
                { id: 'ppi-input-yy-gbp', name: 'PPI Input y/y', dataKey: 'ppiInputYyGbp', unit: '% y/y' },
                { id: 'ppi-output-mm-gbp', name: 'PPI Output m/m', dataKey: 'ppiOutputMmGbp', unit: '% m/m' },
                { id: 'ppi-output-yy-gbp', name: 'PPI Output y/y', dataKey: 'ppiOutputYyGbp', unit: '% y/y' },
                { id: 'boe-interest-rate-decision-gbp', name: 'BoE Interest Rate Decision', dataKey: 'boeInterestRateDecisionGbp', unit: '%' },
                { id: 'boe-mpc-vote-cut-gbp', name: 'BoE MPC Vote Cut', dataKey: 'boeMpcVoteCutGbp', unit: '' }, // No specific unit, just a number
                { id: 'boe-mpc-vote-hike-gbp', name: 'BoE MPC Vote Hike', dataKey: 'boeMpcVoteHikeGbp', unit: '' },
                { id: 'boe-mpc-vote-unchanged-gbp', name: 'BoE MPC Vote Unchanged', dataKey: 'boeMpcVoteUnchangedGbp', unit: '' },
                { id: 'current-account-gbp', name: 'Current Account', dataKey: 'currentAccountGbp', unit: 'Billion' }, // Assuming Billion GBP
                { id: 'trade-balance-gbp', name: 'Trade Balance', dataKey: 'tradeBalanceGbp', unit: 'Billion' }, // Assuming Billion GBP
                { id: 'sp-cips-composite-pmi-gbp', name: 'S&P Global/CIPS Composite PMI', dataKey: 'spCipsCompositePmiGbp', unit: 'Index' },
                { id: 'sp-cips-construction-pmi-gbp', name: 'S&P Global/CIPS Construction PMI', dataKey: 'spCipsConstructionPmiGbp', unit: 'Index' },
                { id: 'sp-cips-manufacturing-pmi-gbp', name: 'S&P Global/CIPS Manufacturing PMI', dataKey: 'spCipsManufacturingPmiGbp', unit: 'Index' },
                { id: 'sp-cips-services-pmi-gbp', name: 'S&P Global/CIPS Services PMI', dataKey: 'spCipsServicesPmiGbp', unit: 'Index' },
                { id: 'core-retail-sales-mm-gbp', name: 'Core Retail Sales m/m', dataKey: 'coreRetailSalesMmGbp', unit: '% m/m' },
                { id: 'core-retail-sales-yy-gbp', name: 'Core Retail Sales y/y', dataKey: 'coreRetailSalesYyGbp', unit: '% y/y' },
                { id: 'gfk-consumer-confidence-gbp', name: 'GfK Consumer Confidence', dataKey: 'gfkConsumerConfidenceGbp', unit: 'Index' },
                { id: 'retail-sales-mm-gbp', name: 'Retail Sales m/m', dataKey: 'retailSalesMmGbp', unit: '% m/m' },
                { id: 'retail-sales-yy-gbp', name: 'Retail Sales y/y', dataKey: 'retailSalesYyGbp', unit: '% y/y' },
            ];

            countrySpecificConfig.GBP.indicatorSetup = gbpIndicatorsBase.map((indicator, index) => {
                const baseColIndex = index * 6; 
                const dateCol = colToExcel(baseColIndex + 0);
                const actualCol = colToExcel(baseColIndex + 1);
                const forecastCol = colToExcel(baseColIndex + 2);
                const surpriseCol = colToExcel(baseColIndex + 4);
                const startRow = 4; 

                return {
                    ...indicator,
                    historicalSheet: 'Historical Data',
                    historicalRanges: {
                        date: `${dateCol}${startRow}:${dateCol}`,
                        actual: `${actualCol}${startRow}:${actualCol}`,
                        forecast: `${forecastCol}${startRow}:${forecastCol}`,
                        surprise: `${surpriseCol}${startRow}:${surpriseCol}`
                    }
                };
            });
        }
        generateGbpHistoricalConfig(); // Populate GBP historical configs


        const macroeconomicData = {}; 
        
        function initializeMacroeconomicData() {
            Object.keys(countrySpecificConfig).forEach(countryCode => {
                macroeconomicData[countryCode] = {
                    hasFetchedAllHistoricalData: false 
                };
                const indicators = countrySpecificConfig[countryCode].indicatorSetup;
                if (indicators && indicators.length > 0) { // Check if indicators are defined
                    indicators.forEach(indicator => {
                        macroeconomicData[countryCode][indicator.dataKey] = {
                            latestActual: '', previousActual: '', latestForecast: '',
                            latestSurprise: '', latestDate: '', 
                            unit: indicator.unit || '', 
                            historicalDates: [], historicalValues: [], historicalForecasts: [],
                            historicalSurprises: [] 
                        };
                    });
                }
            });
        }
        
        // --- Loading Functions ---
        function showFullScreenLoading() { if (fullScreenLoadingOverlay) fullScreenLoadingOverlay.style.display = 'flex'; }
        function hideFullScreenLoading() { if (fullScreenLoadingOverlay) fullScreenLoadingOverlay.style.display = 'none'; }
        function showRightPaneLoading() { if (rightPaneLoadingOverlay) rightPaneLoadingOverlay.style.display = 'flex'; }
        function hideRightPaneLoading() { if (rightPaneLoadingOverlay) rightPaneLoadingOverlay.style.display = 'none'; }

        // --- Dynamic Table Population ---
        function populateMainDataTableHTML(countryCode) {
            mainDataTableBody.innerHTML = ''; 
            const indicators = countrySpecificConfig[countryCode]?.indicatorSetup;

            if (!indicators || indicators.length === 0) {
                const row = mainDataTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 7; 
                cell.textContent = `No indicators configured for ${countryCode}.`;
                cell.style.textAlign = 'center';
                activeIndicatorId = ''; 
                return;
            }

            indicators.forEach((indicator) => { 
                const row = mainDataTableBody.insertRow();
                row.dataset.indicator = indicator.id; 

                row.insertCell().textContent = indicator.name;
                row.insertCell().innerHTML = `<span class="data-value" id="${indicator.id}-value"></span>`;
                row.insertCell().id = `${indicator.id}-previous`;
                row.insertCell().id = `${indicator.id}-forecast`;
                row.insertCell().id = `${indicator.id}-surprise`;
                row.insertCell().innerHTML = `<span class="data-unit-main" id="${indicator.id}-unit"></span>`; 
                row.insertCell().id = `${indicator.id}-date`;

                row.addEventListener('click', async () => { 
                    const newIndicatorId = row.dataset.indicator;
                    if (newIndicatorId && newIndicatorId !== activeIndicatorId) {
                        activeIndicatorId = newIndicatorId;
                    }
                    setActiveIndicatorRow(activeIndicatorId); 
                    await displayHistoricalData(activeIndicatorId, selectedCountry); 
                });
            });
            
            if (indicators.length > 0) {
                activeIndicatorId = indicators[0].id;
                setActiveIndicatorRow(activeIndicatorId);
            } else {
                activeIndicatorId = '';
            }
        }


        // --- Data Fetching Functions ---
        async function fetchLatestDataFromSheet(countryCode) {
            const config = countrySpecificConfig[countryCode];
            if (!config) {
                updateMainDataTable(countryCode); 
                return;
            }

            const sheetId = GOOGLE_SHEET_IDS[config.sheetIdKey];
            if (!sheetId) {
                updateMainDataTable(countryCode);
                return;
            }

            const range = `${config.latestSheetName}!${config.latestSheetRange}`;
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${range}?key=${GOOGLE_API_KEY}`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Google Sheets API request failed for latest data (${countryCode}) with status ${response.status}`);
                }
                const data = await response.json();
                const rows = data.values;
                const cols = config.latestDataColumns; 

                if (rows && rows.length > 0) {
                    config.indicatorSetup.forEach((indicator, index) => {
                        if (rows[index] && macroeconomicData[countryCode] && macroeconomicData[countryCode][indicator.dataKey]) { 
                            const rowData = rows[index]; 
                            const targetIndicatorData = macroeconomicData[countryCode][indicator.dataKey];
                            targetIndicatorData.latestActual = rowData[cols.latest] !== undefined ? rowData[cols.latest] : '';    
                            targetIndicatorData.previousActual = rowData[cols.previous] !== undefined ? rowData[cols.previous] : ''; 
                            targetIndicatorData.latestForecast = rowData[cols.forecast] !== undefined ? rowData[cols.forecast] : ''; 
                            targetIndicatorData.latestSurprise = rowData[cols.surprise] !== undefined ? rowData[cols.surprise] : ''; 
                            targetIndicatorData.latestDate = rowData[cols.date] !== undefined ? rowData[cols.date] : '';     
                            targetIndicatorData.unit = indicator.unit || ''; 
                        }
                    });
                } else {
                    // console.warn(`No latest data returned from Google Sheet for ${countryCode} or sheet is empty for range ${range}.`);
                }
            } catch (error) {
                console.error(`Error fetching latest data for ${countryCode} from Google Sheet:`, error);
            }
        }
        
        async function fetchAllHistoricalDataForCountry(countryCode) {
            const countryConfig = countrySpecificConfig[countryCode];
            if (!countryConfig || !macroeconomicData[countryCode] || macroeconomicData[countryCode].hasFetchedAllHistoricalData) {
                return; 
            }

            const indicatorsWithHistoricalConfig = countryConfig.indicatorSetup.filter(
                ind => ind.historicalSheet && ind.historicalRanges && ind.historicalRanges.date && ind.historicalRanges.actual
            );

            if (indicatorsWithHistoricalConfig.length === 0) {
                macroeconomicData[countryCode].hasFetchedAllHistoricalData = true;
                return; 
            }

            const allRangesToFetch = [];
            indicatorsWithHistoricalConfig.forEach(indConfig => {
                const hr = indConfig.historicalRanges;
                const sheetName = indConfig.historicalSheet;
                if (hr.date) allRangesToFetch.push(`${sheetName}!${hr.date}`);
                if (hr.actual) allRangesToFetch.push(`${sheetName}!${hr.actual}`);
                if (hr.forecast && hr.forecast.trim() !== '') allRangesToFetch.push(`${sheetName}!${hr.forecast}`);
                if (hr.surprise && hr.surprise.trim() !== '') allRangesToFetch.push(`${sheetName}!${hr.surprise}`);
            });

            if (allRangesToFetch.length === 0) {
                macroeconomicData[countryCode].hasFetchedAllHistoricalData = true;
                return;
            }

            const historicalSheetIdKey = countryConfig.sheetIdKey; 
            const sheetId = GOOGLE_SHEET_IDS[historicalSheetIdKey];

            if (!sheetId) {
                macroeconomicData[countryCode].hasFetchedAllHistoricalData = true; 
                return;
            }
            
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values:batchGet?ranges=${allRangesToFetch.map(r => encodeURIComponent(r)).join('&ranges=')}&key=${GOOGLE_API_KEY}`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Google Sheets API batchGet request failed for historical data (${countryCode}) with status ${response.status}`);
                }
                const data = await response.json();
                
                if (data.valueRanges && data.valueRanges.length > 0) {
                    let responseRangeIndex = 0;
                    indicatorsWithHistoricalConfig.forEach(indConfig => {
                         if (!macroeconomicData[countryCode][indConfig.dataKey]) { // Defensive check
                            console.warn(`Data key ${indConfig.dataKey} not found in macroeconomicData for ${countryCode}. Skipping historical data processing for this indicator.`);
                            // Adjust responseRangeIndex if ranges were added for this indicator
                            if (indConfig.historicalRanges.date) responseRangeIndex++;
                            if (indConfig.historicalRanges.actual) responseRangeIndex++;
                            if (indConfig.historicalRanges.forecast && indConfig.historicalRanges.forecast.trim() !== '') responseRangeIndex++;
                            if (indConfig.historicalRanges.surprise && indConfig.historicalRanges.surprise.trim() !== '') responseRangeIndex++;
                            return; 
                        }
                        const targetIndicatorData = macroeconomicData[countryCode][indConfig.dataKey];
                        const hr = indConfig.historicalRanges;

                        const datesRaw = (hr.date && data.valueRanges[responseRangeIndex]) ? (data.valueRanges[responseRangeIndex++]?.values || []) : [];
                        const actualsRaw = (hr.actual && data.valueRanges[responseRangeIndex]) ? (data.valueRanges[responseRangeIndex++]?.values || []) : [];
                        
                        let forecastsRaw = [];
                        if (hr.forecast && hr.forecast.trim() !== '') {
                            if (data.valueRanges[responseRangeIndex]) forecastsRaw = data.valueRanges[responseRangeIndex]?.values || [];
                            responseRangeIndex++;
                        }
                        
                        let surprisesRaw = [];
                        if (hr.surprise && hr.surprise.trim() !== '') {
                             if (data.valueRanges[responseRangeIndex]) surprisesRaw = data.valueRanges[responseRangeIndex]?.values || [];
                             responseRangeIndex++;
                        }

                        targetIndicatorData.historicalDates = datesRaw.map(row => row[0] || '').filter(date => date && date.toString().trim() !== '');
                        const dataLength = targetIndicatorData.historicalDates.length;

                        if (dataLength > 0) {
                            targetIndicatorData.historicalValues = actualsRaw.slice(0, dataLength).map(row => (row && row[0] !== undefined && row[0] !== null) ? row[0] : null);
                            targetIndicatorData.historicalForecasts = forecastsRaw.slice(0, dataLength).map(row => (row && row[0] !== undefined && row[0] !== null) ? row[0] : null);
                            targetIndicatorData.historicalSurprises = surprisesRaw.slice(0, dataLength).map(row => (row && row[0] !== undefined && row[0] !== null) ? row[0] : null);
                        } else {
                            targetIndicatorData.historicalValues = [];
                            targetIndicatorData.historicalForecasts = [];
                            targetIndicatorData.historicalSurprises = [];
                        }
                    });
                } else {
                    // console.warn(`No valueRanges returned from Google Sheet for batch historical data of ${countryCode}.`);
                }
            } catch (error) {
                console.error(`Error fetching batch historical data for ${countryCode}:`, error);
            } finally {
                macroeconomicData[countryCode].hasFetchedAllHistoricalData = true;
            }
        }


        // --- UI Update Functions ---
        function createHorizontalLineMarker(color, width = 20, height = 3) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, (height - 2) / 2, width, 2); 
            const image = new Image();
            image.src = canvas.toDataURL();
            return image;
        }

        function updateMainDataTable(country) {
            const currentCountryData = macroeconomicData[country];
            const indicatorsConfig = countrySpecificConfig[country]?.indicatorSetup;

            if (!currentCountryData || !indicatorsConfig) {
                return;
            }
           
            indicatorsConfig.forEach(indicatorConf => {
                const indicatorData = currentCountryData[indicatorConf.dataKey];
                
                const valueEl = document.getElementById(`${indicatorConf.id}-value`);
                const previousEl = document.getElementById(`${indicatorConf.id}-previous`);
                const forecastEl = document.getElementById(`${indicatorConf.id}-forecast`);
                const surpriseEl = document.getElementById(`${indicatorConf.id}-surprise`);
                const unitEl = document.getElementById(`${indicatorConf.id}-unit`); 
                const dateEl = document.getElementById(`${indicatorConf.id}-date`);

                if (indicatorData) {
                    if(valueEl) valueEl.textContent = indicatorData.latestActual !== undefined ? indicatorData.latestActual : '';
                    if(previousEl) previousEl.textContent = indicatorData.previousActual !== undefined ? indicatorData.previousActual : '';
                    if(forecastEl) forecastEl.textContent = indicatorData.latestForecast !== undefined ? indicatorData.latestForecast : '';
                    if(surpriseEl) surpriseEl.textContent = indicatorData.latestSurprise !== undefined ? indicatorData.latestSurprise : '';
                    if(unitEl) unitEl.textContent = indicatorData.unit || ''; 
                    if(dateEl) dateEl.textContent = indicatorData.latestDate !== undefined ? indicatorData.latestDate : '';
                } else { 
                    if(valueEl) valueEl.textContent = '';
                    if(previousEl) previousEl.textContent = '';
                    if(forecastEl) forecastEl.textContent = '';
                    if(surpriseEl) surpriseEl.textContent = '';
                    if(unitEl) unitEl.textContent = (indicatorConf.unit || '');
                    if(dateEl) dateEl.textContent = '';
                }
            });
           
            setActiveIndicatorRow(activeIndicatorId); 
        }
        
        function getCurrentIndicatorConfig(indicatorId, countryCode) {
            const countryConfig = countrySpecificConfig[countryCode];
            if (!countryConfig || !countryConfig.indicatorSetup) return null;
            return countryConfig.indicatorSetup.find(ind => ind.id === indicatorId);
        }

        async function displayHistoricalData(indicatorId, country) { 
            showRightPaneLoading();
            try {
                const currentIndConfig = getCurrentIndicatorConfig(indicatorId, country);

                if (!currentIndConfig) {
                    historicalDataTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px;">Error: Indicator mapping not found.</td></tr>';
                    if (historicalChartInstance) { historicalChartInstance.destroy(); historicalChartInstance = null; }
                    historicalDataTitleEl.textContent = `Historical Data`;
                    setupLegendButtons(); 
                    hideRightPaneLoading();
                    return;
                }

                historicalDataTitleEl.textContent = `Historical Data - ${currentIndConfig.name}`;
            
                const countryDataStore = macroeconomicData[country];
                const indicatorData = countryDataStore ? countryDataStore[currentIndConfig.dataKey] : null;

                if (!indicatorData) {
                    historicalDataTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px;">No data structure.</td></tr>';
                    if (historicalChartInstance) {
                        historicalChartInstance.data.labels = [];
                        historicalChartInstance.data.datasets.forEach(dataset => { dataset.data = []; });
                        historicalChartInstance.update();
                    }
                    setupLegendButtons(); 
                    hideRightPaneLoading();
                    return;
                }
                
                if (!countryDataStore.hasFetchedAllHistoricalData && currentIndConfig.historicalSheet) {
                     historicalDataTableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding: 20px;">Historical data is loading for ${country}...</td></tr>`;
                     if (historicalChartInstance) { historicalChartInstance.destroy(); historicalChartInstance = null; }
                     setupLegendButtons();
                     hideRightPaneLoading();
                     return;
                }


                const fullHistoricalDates = indicatorData.historicalDates || [];
                const fullHistoricalActuals = indicatorData.historicalValues || [];
                const fullHistoricalForecasts = indicatorData.historicalForecasts || [];
                const fullHistoricalSurprises = indicatorData.historicalSurprises || [];

                let chartDates, chartActuals, chartForecasts, chartSurprises;
                let tableDates, tableActuals, tableForecasts, tableSurprises;

                if (currentDataPointsToShow !== null && currentDataPointsToShow > 0 && fullHistoricalDates.length > 0) {
                    const numPoints = Math.min(currentDataPointsToShow, fullHistoricalDates.length);
                    
                    chartDates = fullHistoricalDates.slice(0, numPoints).reverse();
                    chartActuals = fullHistoricalActuals.slice(0, numPoints).reverse();
                    chartForecasts = fullHistoricalForecasts.slice(0, numPoints).reverse();
                    chartSurprises = fullHistoricalSurprises.slice(0, numPoints).reverse();

                    tableDates = fullHistoricalDates.slice(0, numPoints);
                    tableActuals = fullHistoricalActuals.slice(0, numPoints);
                    tableForecasts = fullHistoricalForecasts.slice(0, numPoints);
                    tableSurprises = fullHistoricalSurprises.slice(0, numPoints);

                } else { 
                    chartDates = [...fullHistoricalDates].reverse();
                    chartActuals = [...fullHistoricalActuals].reverse();
                    chartForecasts = [...fullHistoricalForecasts].reverse();
                    chartSurprises = [...fullHistoricalSurprises].reverse();

                    tableDates = fullHistoricalDates; 
                    tableActuals = fullHistoricalActuals;
                    tableForecasts = fullHistoricalForecasts;
                    tableSurprises = fullHistoricalSurprises;
                }
                
                const unitForChartAndTable = indicatorData.unit || currentIndConfig.unit || '';

                historicalDataTableBody.innerHTML = ''; 
                if (tableDates.length === 0 && !currentIndConfig.historicalSheet) { 
                     historicalDataTableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding: 20px;">Historical data not configured for ${currentIndConfig.name}.</td></tr>`;
                } else if (tableDates.length === 0) { 
                    historicalDataTableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding: 20px;">No historical data available for ${currentIndConfig.name}.</td></tr>`;
                }
                else {
                    tableDates.forEach((year, index) => { 
                        const row = historicalDataTableBody.insertRow();
                        row.insertCell().textContent = year; 
                        const actualVal = tableActuals[index];
                        const forecastVal = tableForecasts[index];
                        const surpriseVal = tableSurprises[index];

                        const formatDisplayValue = (val) => (val !== null && val !== undefined) ? val : '';
                        
                        const actualText = `${formatDisplayValue(actualVal)}${(unitForChartAndTable.startsWith('%') || unitForChartAndTable === 'Index' || unitForChartAndTable === 'K' || unitForChartAndTable === 'M' || unitForChartAndTable.includes('q/q') || unitForChartAndTable.includes('y/y') || unitForChartAndTable === '') ? '' : ' '}${unitForChartAndTable}`;
                        const forecastText = `${formatDisplayValue(forecastVal)}${(unitForChartAndTable.startsWith('%') || unitForChartAndTable === 'Index' || unitForChartAndTable === 'K' || unitForChartAndTable === 'M' || unitForChartAndTable.includes('q/q') || unitForChartAndTable.includes('y/y') || unitForChartAndTable === '') ? '' : ' '}${unitForChartAndTable}`;
                        
                        row.insertCell().textContent = actualVal !== null && actualVal !== undefined ? actualText : '';
                        row.insertCell().textContent = forecastVal !== null && forecastVal !== undefined ? forecastText : '';
                        row.insertCell().textContent = formatDisplayValue(surpriseVal); 
                    });
                }

                const scrollWrapperWidth = historicalChartScrollWrapper.offsetWidth;
                historicalChartCanvasEl.style.width = scrollWrapperWidth + 'px';
                historicalChartCanvasEl.width = scrollWrapperWidth * window.devicePixelRatio; 
                historicalChartCanvasEl.style.height = historicalChartScrollWrapper.offsetHeight + 'px'; 
                historicalChartCanvasEl.height = historicalChartScrollWrapper.offsetHeight * window.devicePixelRatio;

                if (historicalChartInstance) {
                    historicalChartInstance.destroy(); 
                }
            
                if (!forecastMarkerImage) {
                    forecastMarkerImage = createHorizontalLineMarker('rgba(255, 255, 255, 1)', 20, 4); 
                }

                const datasetsTemplate = [ 
                    { 
                        label: `Actual${unitForChartAndTable ? ` (${unitForChartAndTable.trim()})` : ''}`, 
                        data: chartActuals, 
                        backgroundColor: 'rgba(170, 170, 170, 0.7)', 
                        borderColor: 'rgba(170, 170, 170, 1)', 
                        borderWidth: 1, type: 'bar', yAxisID: 'yPrimary', order: 3, hidden: false 
                    },
                    { 
                        label: `Forecast${unitForChartAndTable ? ` (${unitForChartAndTable.trim()})` : ''}`, 
                        data: chartForecasts, 
                        type: 'line', showLine: false, pointStyle: forecastMarkerImage, pointRadius: 10, 
                        pointBackgroundColor: 'rgba(100, 100, 100, 1)', pointBorderColor: 'rgba(100, 100, 100, 1)',   
                        yAxisID: 'yPrimary', order: 2, hidden: false 
                    },
                    { 
                        label: 'Surprise Index', data: chartSurprises, 
                        borderColor: 'rgba(255, 128, 0, 1)', backgroundColor: 'rgba(255, 128, 0, 0.5)', 
                        borderWidth: 2, pointRadius: 3, pointHoverRadius: 5, 
                        yAxisID: 'ySurprise', type: 'line', fill: false, tension: 0.4, order: 1, hidden: true 
                    }
                ];
                
                const activeDatasets = datasetsTemplate.filter(ds => {
                    const hasData = (arr) => arr && arr.length > 0 && arr.some(d => d !== null && d !== undefined && d !== '');
                    if (ds.label.startsWith('Actual')) return hasData(chartActuals) || chartDates.length > 0; 
                    if (ds.label.startsWith('Forecast')) return hasData(chartForecasts);
                    if (ds.label === 'Surprise Index') return hasData(chartSurprises);
                    return false; 
                });
                
                let finalDatasetsForChart = activeDatasets;
                if (activeDatasets.length === 0 && chartDates.length > 0) {
                    finalDatasetsForChart = [datasetsTemplate[0]]; 
                } else if (activeDatasets.length === 0 && chartDates.length === 0) {
                     if (!currentIndConfig.historicalSheet) { 
                        finalDatasetsForChart = [];
                    } else { 
                        finalDatasetsForChart = datasetsTemplate;
                    }
                }


                const ctx = historicalChartCanvasEl.getContext('2d');
                historicalChartInstance = new Chart(ctx, {
                    data: {
                        labels: chartDates, 
                        datasets: finalDatasetsForChart 
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false},
                        scales: {
                            yPrimary: { type: 'linear', display: true, position: 'left', beginAtZero: false, ticks: { color: '#f0f0f0', callback: function(value) { return value + (unitForChartAndTable || ''); }}, grid: { color: 'rgba(255, 255, 255, 0.1)' }, title: { display: true, text: `Value (${unitForChartAndTable.trim() || 'Unit'})`, color: '#f0f0f0'}},
                            ySurprise: { type: 'linear', display: true, position: 'right', beginAtZero: true, ticks: { color: '#f0f0f0' }, grid: { drawOnChartArea: false, }, title: { display: true, text: 'Surprise Index', color: '#f0f0f0'}},
                            x: { ticks: { color: '#f0f0f0', autoSkip: chartDates.length > 15, maxRotation: chartDates.length > 10 ? 70 : 0, minRotation: chartDates.length > 10 ? 70 : 0 }, grid: { display: false }}
                        },
                        plugins: {
                            legend: { display: false }, 
                            tooltip: { 
                                callbacks: { 
                                    label: function(context) { 
                                        let label = context.dataset.label || ''; 
                                        if (label) label += ': '; 
                                        if (context.parsed.y !== null && context.parsed.y !== undefined) { 
                                            label += context.parsed.y; 
                                        } 
                                        return label;
                                    }
                                }
                            }
                        },
                        barPercentage: 0.9, 
                        categoryPercentage: 0.8,  
                    }
                });
            
                const surpriseDataset = historicalChartInstance.data.datasets.find(ds => ds.label === 'Surprise Index');
                historicalChartInstance.options.scales.ySurprise.display = !!(surpriseDataset && !surpriseDataset.hidden && (surpriseDataset.data?.some(d => d !== null)));
                
                historicalChartInstance.update(); 
                setupLegendButtons(); 
            } finally {
                hideRightPaneLoading();
            }
        }
       
        function setActiveIndicatorRow(indicatorIdToActivate) {
            mainDataTableBody.querySelectorAll('tr').forEach(row => {
                row.classList.remove('active-indicator');
                if (row.dataset.indicator === indicatorIdToActivate) {
                    row.classList.add('active-indicator');
                }
            });
        }

        function setupLegendButtons() {
            const currentLegendButtons = document.querySelectorAll('.right-pane .legend-toggle-button');
            if (!historicalChartInstance || !historicalChartInstance.data || !historicalChartInstance.data.datasets) {
                currentLegendButtons.forEach(button => {
                    button.classList.remove('active');
                    button.style.display = 'none'; 
                });
                return;
            }
           
            currentLegendButtons.forEach(button => {
                const datasetIndex = parseInt(button.dataset.datasetIndex);
                const originalDatasetTemplate = [ 
                    `Actual`, `Forecast`, `Surprise Index`
                ];
                const targetLabelPart = originalDatasetTemplate[datasetIndex];
                const dataset = historicalChartInstance.data.datasets.find(ds => ds.label.startsWith(targetLabelPart));


                if (!dataset) { 
                    button.classList.remove('active');
                    button.style.display = 'none'; 
                    const newButton = button.cloneNode(true); 
                    if (button.parentNode) button.parentNode.replaceChild(newButton, button);
                    return;
                }
                button.style.display = ''; 

                const isInitiallyVisible = !dataset.hidden;
                button.classList.toggle('active', isInitiallyVisible);
                                           
                const newButton = button.cloneNode(true); 
                if (button.parentNode) { 
                    button.parentNode.replaceChild(newButton, button);
                } else {
                    return; 
                }

                newButton.addEventListener('click', () => {
                    const liveDataset = historicalChartInstance.data.datasets.find(ds => ds.label.startsWith(targetLabelPart));
                    if (!historicalChartInstance || !liveDataset) return; 

                    const datasetActualIndexInChart = historicalChartInstance.data.datasets.indexOf(liveDataset);
                    if (datasetActualIndexInChart === -1) return; 

                    const currentVisibility = historicalChartInstance.isDatasetVisible(datasetActualIndexInChart);
                    historicalChartInstance.setDatasetVisibility(datasetActualIndexInChart, !currentVisibility);
                    newButton.classList.toggle('active', !currentVisibility);

                    if (liveDataset.label === 'Surprise Index') { 
                        historicalChartInstance.options.scales.ySurprise.display = !currentVisibility && (liveDataset.data?.some(d => d !== null));
                    }
                    historicalChartInstance.update();
                });
            });
        }
       
        // --- Resizer Logic ---
        const resizer = document.createElement('div');
        resizer.className = 'resizer-x';
        if (rightPane && rightPane.parentNode === contentContainer) { 
            contentContainer.insertBefore(resizer, rightPane); 
        } else {
            console.error("Right pane or content container not found for resizer insertion.");
        }

        let isResizing = false;
        let startX, startLeftWidth;
        const minPaneWidth = 150; 

        resizer.addEventListener('mousedown', function(e) {
            e.preventDefault(); 
            isResizing = true;
            startX = e.clientX;
            startLeftWidth = leftPane.offsetWidth;
            document.body.style.cursor = 'col-resize'; 

            document.addEventListener('mousemove', handleResizerMouseMove);
            document.addEventListener('mouseup', handleResizerMouseUp);
        });

        function handleResizerMouseMove(e) {
            if (!isResizing) return;
            const deltaX = e.clientX - startX;
            let newLeftWidth = startLeftWidth + deltaX;
           
            const containerWidth = contentContainer.offsetWidth;
            const resizerWidth = resizer.offsetWidth;

            if (newLeftWidth < minPaneWidth) {
                newLeftWidth = minPaneWidth;
            }
            if (containerWidth - newLeftWidth - resizerWidth < minPaneWidth) {
                newLeftWidth = containerWidth - minPaneWidth - resizerWidth;
            }

            leftPane.style.width = newLeftWidth + 'px';
            rightPane.style.width = (containerWidth - newLeftWidth - resizerWidth) + 'px';
        }

        function handleResizerMouseUp() {
            if (!isResizing) return;
            isResizing = false;
            document.body.style.cursor = 'default'; 

            document.removeEventListener('mousemove', handleResizerMouseMove);
            document.removeEventListener('mouseup', handleResizerMouseUp);

            handlePanesResized();
        }

        async function handlePanesResized() { 
            try {
                if (historicalChartInstance && activeIndicatorId) { 
                    await displayHistoricalData(activeIndicatorId, selectedCountry); 
                }
            } catch(e) {
                console.error("Error during pane resize handling:", e);
            }
        }

        // --- Event Listeners ---
        countrySelect.addEventListener('change', async (event) => { 
            showFullScreenLoading();
            selectedCountry = event.target.value;
            currentDataPointsToShow = 15; 
            dataPointsInput.value = '15';
            
            // Ensure data structure exists, if not, initialize it
            if (!macroeconomicData[selectedCountry] && countrySpecificConfig[selectedCountry]) {
                 initializeMacroeconomicData(); 
            } else if (!countrySpecificConfig[selectedCountry]) {
                 mainDataTableBody.innerHTML = `<tr><td colspan="7" style="text-align:center;">No configuration for ${selectedCountry}</td></tr>`;
                 activeIndicatorId = '';
                 historicalDataTitleEl.textContent = 'Historical Data';
                 historicalDataTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">No data</td></tr>';
                 if(historicalChartInstance) { historicalChartInstance.destroy(); historicalChartInstance = null; }
                 setupLegendButtons();
                 hideFullScreenLoading();
                 return;
            }
            
            populateMainDataTableHTML(selectedCountry); 

            if (!macroeconomicData[selectedCountry] || !macroeconomicData[selectedCountry].hasFetchedAllHistoricalData) {
                macroeconomicData[selectedCountry].hasFetchedAllHistoricalData = false; 
                
                await fetchLatestDataFromSheet(selectedCountry); 
                await fetchAllHistoricalDataForCountry(selectedCountry); 
            }
            
            updateMainDataTable(selectedCountry); 

            if (activeIndicatorId) { 
                await displayHistoricalData(activeIndicatorId, selectedCountry); 
            } else { 
                historicalDataTitleEl.textContent = 'Historical Data';
                historicalDataTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px;">Select an indicator.</td></tr>';
                if (historicalChartInstance) { historicalChartInstance.destroy(); historicalChartInstance = null; }
                setupLegendButtons(); 
            }
            hideFullScreenLoading();
        });
       
        async function applyDataPointsFilter() { 
            const numPoints = parseInt(dataPointsInput.value);
            if (!isNaN(numPoints) && numPoints >= (parseInt(dataPointsInput.min) || 1)) {
                currentDataPointsToShow = numPoints;
            } else if (dataPointsInput.value === '') { 
                 currentDataPointsToShow = 15; 
                 dataPointsInput.value = '15';
            } else { 
                currentDataPointsToShow = 15; 
                dataPointsInput.value = '15'; 
            }
            if (activeIndicatorId) await displayHistoricalData(activeIndicatorId, selectedCountry); 
        }

        dataPointsInput.addEventListener('input', applyDataPointsFilter);

        dataPointsInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                applyDataPointsFilter();
            }
        });

        showAllDataButton.addEventListener('click', async () => { 
            currentDataPointsToShow = null; 
            const indicatorConf = getCurrentIndicatorConfig(activeIndicatorId, selectedCountry);
            if (indicatorConf && macroeconomicData[selectedCountry] && macroeconomicData[selectedCountry][indicatorConf.dataKey]) {
                const indicatorData = macroeconomicData[selectedCountry][indicatorConf.dataKey];
                dataPointsInput.value = indicatorData?.historicalDates?.length > 0 ? indicatorData.historicalDates.length : '15'; 
            } else {
                dataPointsInput.value = '15';
            }
            if (activeIndicatorId) await displayHistoricalData(activeIndicatorId, selectedCountry); 
        });

        decreaseDataPointsButton.addEventListener('click', () => { 
            let currentValue = parseInt(dataPointsInput.value) || 15; 
            const minValue = parseInt(dataPointsInput.min) || 1;
            if (currentValue > minValue) {
                dataPointsInput.value = currentValue - 1;
            } else {
                dataPointsInput.value = minValue;
            }
            applyDataPointsFilter(); 
        });

        increaseDataPointsButton.addEventListener('click', () => { 
            let currentValue = parseInt(dataPointsInput.value) || 15; 
            const indicatorConf = getCurrentIndicatorConfig(activeIndicatorId, selectedCountry);
            let maxPoints = currentValue + 10; 
            if (indicatorConf && macroeconomicData[selectedCountry] && macroeconomicData[selectedCountry][indicatorConf.dataKey]) {
                const indicatorDataObj = macroeconomicData[selectedCountry][indicatorConf.dataKey];
                if (indicatorDataObj && indicatorDataObj.historicalDates && indicatorDataObj.historicalDates.length > 0) {
                    maxPoints = indicatorDataObj.historicalDates.length;
                }
            }
            
            if (currentValue < maxPoints) { 
                 dataPointsInput.value = currentValue + 1;
            } else if (maxPoints !== currentValue + 10) { 
                 dataPointsInput.value = maxPoints;
            }
            applyDataPointsFilter(); 
        });


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => { 
            showFullScreenLoading();
            initializeMacroeconomicData(); 
            
            countrySelect.value = selectedCountry; 
            dataPointsInput.value = '15'; 

            if (!forecastMarkerImage) {
                forecastMarkerImage = createHorizontalLineMarker('rgba(255, 255, 255, 1)', 20, 4); 
            }
            
            populateMainDataTableHTML(selectedCountry); 
            
            await fetchLatestDataFromSheet(selectedCountry); 
            await fetchAllHistoricalDataForCountry(selectedCountry); 
            
            updateMainDataTable(selectedCountry); 
            
            if (activeIndicatorId) { 
                await displayHistoricalData(activeIndicatorId, selectedCountry); 
            } else {
                historicalDataTitleEl.textContent = 'Historical Data';
                historicalDataTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px;">Select an indicator.</td></tr>';
                 if (historicalChartInstance) { historicalChartInstance.destroy(); historicalChartInstance = null; }
                 setupLegendButtons();
            }
            hideFullScreenLoading();
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(async () => { 
                await handlePanesResized(); 
            }, 250); 
        });

    </script>
</body>
</html>
